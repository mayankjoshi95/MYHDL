###A hardware module (called a block in MyHDL terminology) is modeled as a function that returns generators.
This approach makes it straightforward to support features such as arbitrary hierarchy, named port association, arrays of instances, and conditional instantiation. 
Furthermore, MyHDL provides classes that implement traditional hardware description concepts.
It provides a signal class to support communication between generators, a class to support bit oriented operations, and a class for enumeration types.
Simulation and Verification

The built-in simulator runs on top of the Python interpreter. It supports waveform viewing by tracing signal changes in a VCD file.

With MyHDL, the Python unit test framework can be used on hardware designs. Although unit testing is a popular modern software verification technique, it is still uncommon in the hardware design world.

MyHDL can also be used as hardware verification language for Verilog designs, by co-simulation with traditional HDL simulators.

Conversion to Verilog and VHDL

Subject to some limitations, MyHDL designs can be converted to Verilog or VHDL. This provides a path into a traditional design flow, including synthesis and implementation. The convertible subset is restricted, but much wider than the standard synthesis subset. It includes features that can be used for high level modeling and test benches.

The converter works on an instantiated design that has been fully elaborated. Consequently, the original design structure can be arbitrarily complex. Moreover, the conversion limitations apply only to code inside generators. Outside generators, Python’s full power can be used without compromising convertibility.

Finally, the converter automates a number of tasks that are hard in Verilog or VHDL directly. A notable feature is the automated handling of signed arithmetic issues.

####YIELD STATEMENTS WORK AS GENERAL SENSITIVTY LISTS 
@deco
def func(arg1, arg2, ...):
    <body>
This code is equivalent to the following:

def func(arg1, arg2, ...):
    <body>
func = deco(func)
##Note that the decorator statement goes directly in front of the function declaration, and that the function name func is automatically reused for the final result.
###MyHDL uses decorators to create ready-to-simulate generators from local function definitions.

##def disp():#2since show is not called yet thus it return show and r_sh =show 
    def show():#4.it returns the value "show function" and we get "show ficntion gets printed "
        return "Show Function"
    print("Disp Fucntion")##this print statement is for the outer fucntion
    return show##the outer funciton  return this function
r_sh= disp()##1.it calls to the disp function
print(r_sh())#3.now it is read as show() i.e the show function gets called 
Disp Fucntion
Show Function


def disp(sh):##2, after calling it PRINT the "Disp Funciton"returns the show now r_sh=show 
    print("Disp Function")
    return sh
def show():
    return"Show Function"
r_sh=disp(show)###1. here disp function gets called
print(r_sh())##3.now the show() is called then it print the "Show Function"##A BASIC MYHDL SIMULATION


##myhdl



from myhdl import block,delay,always,now##here we impoert number of object from the python 
@block##in myhdl a hardware module is modeled by a function decorated with block decorator   
def HelloWorld():##parameter list is used to define the inteface of the hardware block 
    @always(delay(10))##always decorator has the dely object as its parameter 
    ##it means fucntion will execute whenever the specified delay has expired 
    def say_hello():##it defines the desired behaviour ##THis is the return of the top HelloWorld
        print("%s Hello World!"%now())##now returns the current simulation time 
    return say_hello    
inst=HelloWorld()#n MyHDL, we create an instance of a hardware block by calling the corresponding function. 
#The block decorator make sure that the return value is actually an instance of a block class, with a useful API.
#In the example, variable inst refers to a HelloWorld block instance.
inst.run_sim(30)##to simulate the instance we use its run_sim method.we can use it to run the simulation for desired amount of 
#timesteps .

##intbv
intbv([val=None] [, min=None]  [, max=None])
#val is the initial value. min and max can be used to constrain the value. Following the Python conventions, min is inclusive, and max is exclusive. 
#Therefore, the allowed value range is min .. max-1.
Python function len can be used to determine the bit width.
len(a)


##We use the bin function provide by MyHDL because it shows the two’s complement representation for negative values.

from myhdl import bin
a=intbv(24)
bin(a)
'11000'

##bit indexing 
from myhdl import bin
a=intbv(24)##it gives us the hexadecimal number 
bin(a)
'11000'
print(int(a[4]))
print(int(a[3]))
print(int(a[2]))
print(int(a[1]))
print(int(a[0]))
1
1
0
0
0

##notice that lower indices corresponds to les significant bit 



##in case of bit slicing higher index is left off i.e the leftmost bit is not considered

print(bin(a[4:1]))
100


print(bin(a[4:]))
1000


##When an intbv object is sliced, a new intbv object is returned.
This new intbv object is always positive, and the value bounds are set up in accordance with the bit width specified by the slice.
For example:

b=a[4:]
print(b.min)
0
print(b.max)
16

##sometimes hardware engineers prefer to constrain an object by defining its bit width directly, instead of the range of allowed values.


##In some cases it can be useful to interpret intbv objects in terms of “signed” and “unsigned”. Basically, it depends on attribute min. 
if min < 0, then the object is “signed”, otherwise it is “unsigned”. 
##In particular, the bit width of a “signed” object will account for a sign bit, but that of an “unsigned” will not, because that would be redundant. 
